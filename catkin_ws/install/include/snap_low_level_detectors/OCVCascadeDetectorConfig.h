//#line 2 "/opt/ros/indigo/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"
// *********************************************************
// 
// File autogenerated for the snap_low_level_detectors package 
// by the dynamic_reconfigure package.
// Please do not edit.
// 
// ********************************************************/

#ifndef __snap_low_level_detectors__OCVCASCADEDETECTORCONFIG_H__
#define __snap_low_level_detectors__OCVCASCADEDETECTORCONFIG_H__

#include <dynamic_reconfigure/config_tools.h>
#include <limits>
#include <ros/node_handle.h>
#include <dynamic_reconfigure/ConfigDescription.h>
#include <dynamic_reconfigure/ParamDescription.h>
#include <dynamic_reconfigure/Group.h>
#include <dynamic_reconfigure/config_init_mutex.h>
#include <boost/any.hpp>

namespace snap_low_level_detectors
{
  class OCVCascadeDetectorConfigStatics;
  
  class OCVCascadeDetectorConfig
  {
  public:
    class AbstractParamDescription : public dynamic_reconfigure::ParamDescription
    {
    public:
      AbstractParamDescription(std::string n, std::string t, uint32_t l, 
          std::string d, std::string e)
      {
        name = n;
        type = t;
        level = l;
        description = d;
        edit_method = e;
      }
      
      virtual void clamp(OCVCascadeDetectorConfig &config, const OCVCascadeDetectorConfig &max, const OCVCascadeDetectorConfig &min) const = 0;
      virtual void calcLevel(uint32_t &level, const OCVCascadeDetectorConfig &config1, const OCVCascadeDetectorConfig &config2) const = 0;
      virtual void fromServer(const ros::NodeHandle &nh, OCVCascadeDetectorConfig &config) const = 0;
      virtual void toServer(const ros::NodeHandle &nh, const OCVCascadeDetectorConfig &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, OCVCascadeDetectorConfig &config) const = 0;
      virtual void toMessage(dynamic_reconfigure::Config &msg, const OCVCascadeDetectorConfig &config) const = 0;
      virtual void getValue(const OCVCascadeDetectorConfig &config, boost::any &val) const = 0;
    };

    typedef boost::shared_ptr<AbstractParamDescription> AbstractParamDescriptionPtr;
    typedef boost::shared_ptr<const AbstractParamDescription> AbstractParamDescriptionConstPtr;
    
    template <class T>
    class ParamDescription : public AbstractParamDescription
    {
    public:
      ParamDescription(std::string name, std::string type, uint32_t level, 
          std::string description, std::string edit_method, T OCVCascadeDetectorConfig::* f) :
        AbstractParamDescription(name, type, level, description, edit_method),
        field(f)
      {}

      T (OCVCascadeDetectorConfig::* field);

      virtual void clamp(OCVCascadeDetectorConfig &config, const OCVCascadeDetectorConfig &max, const OCVCascadeDetectorConfig &min) const
      {
        if (config.*field > max.*field)
          config.*field = max.*field;
        
        if (config.*field < min.*field)
          config.*field = min.*field;
      }

      virtual void calcLevel(uint32_t &comb_level, const OCVCascadeDetectorConfig &config1, const OCVCascadeDetectorConfig &config2) const
      {
        if (config1.*field != config2.*field)
          comb_level |= level;
      }

      virtual void fromServer(const ros::NodeHandle &nh, OCVCascadeDetectorConfig &config) const
      {
        nh.getParam(name, config.*field);
      }

      virtual void toServer(const ros::NodeHandle &nh, const OCVCascadeDetectorConfig &config) const
      {
        nh.setParam(name, config.*field);
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, OCVCascadeDetectorConfig &config) const
      {
        return dynamic_reconfigure::ConfigTools::getParameter(msg, name, config.*field);
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const OCVCascadeDetectorConfig &config) const
      {
        dynamic_reconfigure::ConfigTools::appendParameter(msg, name, config.*field);
      }

      virtual void getValue(const OCVCascadeDetectorConfig &config, boost::any &val) const
      {
        val = config.*field;
      }
    };

    class AbstractGroupDescription : public dynamic_reconfigure::Group
    {
      public:
      AbstractGroupDescription(std::string n, std::string t, int p, int i, bool s)
      {
        name = n;
        type = t;
        parent = p;
        state = s;
        id = i;
      }

      std::vector<AbstractParamDescriptionConstPtr> abstract_parameters;
      bool state;

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &config) const =0;
      virtual void updateParams(boost::any &cfg, OCVCascadeDetectorConfig &top) const= 0;
      virtual void setInitialState(boost::any &cfg) const = 0;


      void convertParams()
      {
        for(std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = abstract_parameters.begin(); i != abstract_parameters.end(); ++i)
        {
          parameters.push_back(dynamic_reconfigure::ParamDescription(**i));
        }
      }
    };

    typedef boost::shared_ptr<AbstractGroupDescription> AbstractGroupDescriptionPtr;
    typedef boost::shared_ptr<const AbstractGroupDescription> AbstractGroupDescriptionConstPtr;

    template<class T, class PT>
    class GroupDescription : public AbstractGroupDescription
    {
    public:
      GroupDescription(std::string name, std::string type, int parent, int id, bool s, T PT::* f) : AbstractGroupDescription(name, type, parent, id, s), field(f)
      {
      }

      GroupDescription(const GroupDescription<T, PT>& g): AbstractGroupDescription(g.name, g.type, g.parent, g.id, g.state), field(g.field), groups(g.groups)
      {
        parameters = g.parameters;
        abstract_parameters = g.abstract_parameters;
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &cfg) const
      {
        PT* config = boost::any_cast<PT*>(cfg);
        if(!dynamic_reconfigure::ConfigTools::getGroupState(msg, name, (*config).*field))
          return false;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          if(!(*i)->fromMessage(msg, n))
            return false;
        }

        return true;
      }

      virtual void setInitialState(boost::any &cfg) const
      {
        PT* config = boost::any_cast<PT*>(cfg);
        T* group = &((*config).*field);
        group->state = state;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = boost::any(&((*config).*field));
          (*i)->setInitialState(n);
        }

      }

      virtual void updateParams(boost::any &cfg, OCVCascadeDetectorConfig &top) const
      {
        PT* config = boost::any_cast<PT*>(cfg);

        T* f = &((*config).*field);
        f->setParams(top, abstract_parameters);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          (*i)->updateParams(n, top);
        }
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &cfg) const
      {
        const PT config = boost::any_cast<PT>(cfg);
        dynamic_reconfigure::ConfigTools::appendGroup<T>(msg, name, id, parent, config.*field);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          (*i)->toMessage(msg, config.*field);
        }
      }

      T (PT::* field);
      std::vector<OCVCascadeDetectorConfig::AbstractGroupDescriptionConstPtr> groups;
    };
    
class DEFAULT
{
  public:
    DEFAULT()
    {
      state = true;
      name = "Default";
    }

    void setParams(OCVCascadeDetectorConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("scale_factor"==(*_i)->name){scale_factor = boost::any_cast<double>(val);}
        if("min_neighbors"==(*_i)->name){min_neighbors = boost::any_cast<int>(val);}
        if("min_width"==(*_i)->name){min_width = boost::any_cast<int>(val);}
        if("min_height"==(*_i)->name){min_height = boost::any_cast<int>(val);}
        if("max_width"==(*_i)->name){max_width = boost::any_cast<int>(val);}
        if("max_height"==(*_i)->name){max_height = boost::any_cast<int>(val);}
        if("flags"==(*_i)->name){flags = boost::any_cast<int>(val);}
      }
    }

    double scale_factor;
int min_neighbors;
int min_width;
int min_height;
int max_width;
int max_height;
int flags;

    bool state;
    std::string name;

    
}groups;



//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double scale_factor;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int min_neighbors;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int min_width;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int min_height;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int max_width;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int max_height;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int flags;
//#line 218 "/opt/ros/indigo/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

    bool __fromMessage__(dynamic_reconfigure::Config &msg)
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();

      int count = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        if ((*i)->fromMessage(msg, *this))
          count++;

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i ++)
      {
        if ((*i)->id == 0)
        {
          boost::any n = boost::any(this);
          (*i)->updateParams(n, *this);
          (*i)->fromMessage(msg, n);
        }
      }

      if (count != dynamic_reconfigure::ConfigTools::size(msg))
      {
        ROS_ERROR("OCVCascadeDetectorConfig::__fromMessage__ called with an unexpected parameter.");
        ROS_ERROR("Booleans:");
        for (unsigned int i = 0; i < msg.bools.size(); i++)
          ROS_ERROR("  %s", msg.bools[i].name.c_str());
        ROS_ERROR("Integers:");
        for (unsigned int i = 0; i < msg.ints.size(); i++)
          ROS_ERROR("  %s", msg.ints[i].name.c_str());
        ROS_ERROR("Doubles:");
        for (unsigned int i = 0; i < msg.doubles.size(); i++)
          ROS_ERROR("  %s", msg.doubles[i].name.c_str());
        ROS_ERROR("Strings:");
        for (unsigned int i = 0; i < msg.strs.size(); i++)
          ROS_ERROR("  %s", msg.strs[i].name.c_str());
        // @todo Check that there are no duplicates. Make this error more
        // explicit.
        return false;
      }
      return true;
    }

    // This version of __toMessage__ is used during initialization of
    // statics when __getParamDescriptions__ can't be called yet.
    void __toMessage__(dynamic_reconfigure::Config &msg, const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__, const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__) const
    {
      dynamic_reconfigure::ConfigTools::clear(msg);
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toMessage(msg, *this);

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        if((*i)->id == 0)
        {
          (*i)->toMessage(msg, *this);
        }
      }
    }
    
    void __toMessage__(dynamic_reconfigure::Config &msg) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      __toMessage__(msg, __param_descriptions__, __group_descriptions__);
    }
    
    void __toServer__(const ros::NodeHandle &nh) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toServer(nh, *this);
    }

    void __fromServer__(const ros::NodeHandle &nh)
    {
      static bool setup=false;

      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->fromServer(nh, *this);

      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i++){
        if (!setup && (*i)->id == 0) {
          setup = true;
          boost::any n = boost::any(this);
          (*i)->setInitialState(n);
        }
      }
    }

    void __clamp__()
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const OCVCascadeDetectorConfig &__max__ = __getMax__();
      const OCVCascadeDetectorConfig &__min__ = __getMin__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->clamp(*this, __max__, __min__);
    }

    uint32_t __level__(const OCVCascadeDetectorConfig &config) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      uint32_t level = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->calcLevel(level, config, *this);
      return level;
    }
    
    static const dynamic_reconfigure::ConfigDescription &__getDescriptionMessage__();
    static const OCVCascadeDetectorConfig &__getDefault__();
    static const OCVCascadeDetectorConfig &__getMax__();
    static const OCVCascadeDetectorConfig &__getMin__();
    static const std::vector<AbstractParamDescriptionConstPtr> &__getParamDescriptions__();
    static const std::vector<AbstractGroupDescriptionConstPtr> &__getGroupDescriptions__();
    
  private:
    static const OCVCascadeDetectorConfigStatics *__get_statics__();
  };
  
  template <> // Max and min are ignored for strings.
  inline void OCVCascadeDetectorConfig::ParamDescription<std::string>::clamp(OCVCascadeDetectorConfig &config, const OCVCascadeDetectorConfig &max, const OCVCascadeDetectorConfig &min) const
  {
    return;
  }

  class OCVCascadeDetectorConfigStatics
  {
    friend class OCVCascadeDetectorConfig;
    
    OCVCascadeDetectorConfigStatics()
    {
OCVCascadeDetectorConfig::GroupDescription<OCVCascadeDetectorConfig::DEFAULT, OCVCascadeDetectorConfig> Default("Default", "", 0, 0, true, &OCVCascadeDetectorConfig::groups);
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.scale_factor = 1.05;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.scale_factor = 3.0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.scale_factor = 1.2;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<double>("scale_factor", "double", 0, "Parameter specifying how much the image size is reduced at each image scale", "", &OCVCascadeDetectorConfig::scale_factor)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<double>("scale_factor", "double", 0, "Parameter specifying how much the image size is reduced at each image scale", "", &OCVCascadeDetectorConfig::scale_factor)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.min_neighbors = 0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.min_neighbors = 100;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.min_neighbors = 10;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("min_neighbors", "int", 0, "Parameter specifying how many neighbors each candidate rectangle should have to retain it.", "", &OCVCascadeDetectorConfig::min_neighbors)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("min_neighbors", "int", 0, "Parameter specifying how many neighbors each candidate rectangle should have to retain it.", "", &OCVCascadeDetectorConfig::min_neighbors)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.min_width = 0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.min_width = 1000;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.min_width = 32;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("min_width", "int", 0, "Minimum possible object width. Objects smaller than that are ignored.", "", &OCVCascadeDetectorConfig::min_width)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("min_width", "int", 0, "Minimum possible object width. Objects smaller than that are ignored.", "", &OCVCascadeDetectorConfig::min_width)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.min_height = 0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.min_height = 1000;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.min_height = 32;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("min_height", "int", 0, "Minimum possible object height. Objects smaller than that are ignored.", "", &OCVCascadeDetectorConfig::min_height)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("min_height", "int", 0, "Minimum possible object height. Objects smaller than that are ignored.", "", &OCVCascadeDetectorConfig::min_height)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.max_width = 0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.max_width = 1000;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.max_width = 512;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("max_width", "int", 0, "Maximum possible object width. Objects larger than that are ignored.", "", &OCVCascadeDetectorConfig::max_width)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("max_width", "int", 0, "Maximum possible object width. Objects larger than that are ignored.", "", &OCVCascadeDetectorConfig::max_width)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.max_height = 0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.max_height = 1000;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.max_height = 512;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("max_height", "int", 0, "Maximum possible object height. Objects larger than that are ignored.", "", &OCVCascadeDetectorConfig::max_height)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("max_height", "int", 0, "Maximum possible object height. Objects larger than that are ignored.", "", &OCVCascadeDetectorConfig::max_height)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.flags = 0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.flags = 1;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.flags = 0;
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("flags", "int", 0, "Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade.", "{'enum_description': 'Mode of operation', 'enum': [{'srcline': 15, 'description': 'No pruning before cascade detection. Not supported anyway for new-style cascades.', 'srcfile': '/home/yongbo/Documents/PennApps/catkin_ws/src/snap_low_level_detectors/cfg/OCVCascadeDetector.cfg', 'cconsttype': 'const int', 'value': 0, 'ctype': 'int', 'type': 'int', 'name': 'CV_HAAR_NO_PRUNING'}, {'srcline': 16, 'description': 'Uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing', 'srcfile': '/home/yongbo/Documents/PennApps/catkin_ws/src/snap_low_level_detectors/cfg/OCVCascadeDetector.cfg', 'cconsttype': 'const int', 'value': 1, 'ctype': 'int', 'type': 'int', 'name': 'CV_HAAR_DO_CANNY_PRUNING'}]}", &OCVCascadeDetectorConfig::flags)));
//#line 262 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr(new OCVCascadeDetectorConfig::ParamDescription<int>("flags", "int", 0, "Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. It is not used for a new cascade.", "{'enum_description': 'Mode of operation', 'enum': [{'srcline': 15, 'description': 'No pruning before cascade detection. Not supported anyway for new-style cascades.', 'srcfile': '/home/yongbo/Documents/PennApps/catkin_ws/src/snap_low_level_detectors/cfg/OCVCascadeDetector.cfg', 'cconsttype': 'const int', 'value': 0, 'ctype': 'int', 'type': 'int', 'name': 'CV_HAAR_NO_PRUNING'}, {'srcline': 16, 'description': 'Uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing', 'srcfile': '/home/yongbo/Documents/PennApps/catkin_ws/src/snap_low_level_detectors/cfg/OCVCascadeDetector.cfg', 'cconsttype': 'const int', 'value': 1, 'ctype': 'int', 'type': 'int', 'name': 'CV_HAAR_DO_CANNY_PRUNING'}]}", &OCVCascadeDetectorConfig::flags)));
//#line 233 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.convertParams();
//#line 233 "/opt/ros/indigo/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(OCVCascadeDetectorConfig::AbstractGroupDescriptionConstPtr(new OCVCascadeDetectorConfig::GroupDescription<OCVCascadeDetectorConfig::DEFAULT, OCVCascadeDetectorConfig>(Default)));
//#line 353 "/opt/ros/indigo/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

      for (std::vector<OCVCascadeDetectorConfig::AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        __description_message__.groups.push_back(**i);
      }
      __max__.__toMessage__(__description_message__.max, __param_descriptions__, __group_descriptions__); 
      __min__.__toMessage__(__description_message__.min, __param_descriptions__, __group_descriptions__); 
      __default__.__toMessage__(__description_message__.dflt, __param_descriptions__, __group_descriptions__); 
    }
    std::vector<OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr> __param_descriptions__;
    std::vector<OCVCascadeDetectorConfig::AbstractGroupDescriptionConstPtr> __group_descriptions__;
    OCVCascadeDetectorConfig __max__;
    OCVCascadeDetectorConfig __min__;
    OCVCascadeDetectorConfig __default__;
    dynamic_reconfigure::ConfigDescription __description_message__;

    static const OCVCascadeDetectorConfigStatics *get_instance()
    {
      // Split this off in a separate function because I know that
      // instance will get initialized the first time get_instance is
      // called, and I am guaranteeing that get_instance gets called at
      // most once.
      static OCVCascadeDetectorConfigStatics instance;
      return &instance;
    }
  };

  inline const dynamic_reconfigure::ConfigDescription &OCVCascadeDetectorConfig::__getDescriptionMessage__() 
  {
    return __get_statics__()->__description_message__;
  }

  inline const OCVCascadeDetectorConfig &OCVCascadeDetectorConfig::__getDefault__()
  {
    return __get_statics__()->__default__;
  }
  
  inline const OCVCascadeDetectorConfig &OCVCascadeDetectorConfig::__getMax__()
  {
    return __get_statics__()->__max__;
  }
  
  inline const OCVCascadeDetectorConfig &OCVCascadeDetectorConfig::__getMin__()
  {
    return __get_statics__()->__min__;
  }
  
  inline const std::vector<OCVCascadeDetectorConfig::AbstractParamDescriptionConstPtr> &OCVCascadeDetectorConfig::__getParamDescriptions__()
  {
    return __get_statics__()->__param_descriptions__;
  }

  inline const std::vector<OCVCascadeDetectorConfig::AbstractGroupDescriptionConstPtr> &OCVCascadeDetectorConfig::__getGroupDescriptions__()
  {
    return __get_statics__()->__group_descriptions__;
  }

  inline const OCVCascadeDetectorConfigStatics *OCVCascadeDetectorConfig::__get_statics__()
  {
    const static OCVCascadeDetectorConfigStatics *statics;
  
    if (statics) // Common case
      return statics;

    boost::mutex::scoped_lock lock(dynamic_reconfigure::__init_mutex__);

    if (statics) // In case we lost a race.
      return statics;

    statics = OCVCascadeDetectorConfigStatics::get_instance();
    
    return statics;
  }

//#line 15 "/home/yongbo/Documents/PennApps/catkin_ws/src/snap_low_level_detectors/cfg/OCVCascadeDetector.cfg"
      const int OCVCascadeDetector_CV_HAAR_NO_PRUNING = 0;
//#line 16 "/home/yongbo/Documents/PennApps/catkin_ws/src/snap_low_level_detectors/cfg/OCVCascadeDetector.cfg"
      const int OCVCascadeDetector_CV_HAAR_DO_CANNY_PRUNING = 1;
}

#endif // __OCVCASCADEDETECTORRECONFIGURATOR_H__
